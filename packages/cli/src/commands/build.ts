/* eslint-disable no-console */
import * as fs from 'fs'
import * as path from 'path'
import * as jsYaml from 'js-yaml'
import fg from 'fast-glob'
import micromatch from 'micromatch'
import { pathToFileURL } from 'url'
import { Context, type Workflow } from '@github-actions-workflow-ts/lib'
import type { WacConfig } from './types/index.js'
import { ConsoleDiagnosticsReporter } from './diagnostics.js'

/**
 * Default output path for workflow files.
 */
export const DEFAULT_OUTPUT_PATH = path.join('.github', 'workflows')

/**
 * Finds the project root directory by looking for markers like .git or package.json.
 * Walks up the directory tree from the current working directory.
 *
 * @param {string} [startDir] - The directory to start searching from. Defaults to cwd.
 * @returns {string} - The project root directory, or cwd if no markers found.
 */
export const findProjectRoot = (startDir?: string): string => {
  let currentDir = startDir || process.cwd()
  const root = path.parse(currentDir).root

  while (currentDir !== root) {
    // Check for .git directory (most reliable indicator of project root)
    if (fs.existsSync(path.join(currentDir, '.git'))) {
      return currentDir
    }

    // Check for package.json as fallback (could be in a workspace package)
    // Only use if it has workspaces defined (indicating it's the root)
    const packageJsonPath = path.join(currentDir, 'package.json')
    if (fs.existsSync(packageJsonPath)) {
      try {
        const packageJson = JSON.parse(
          fs.readFileSync(packageJsonPath, 'utf-8'),
        )
        // If it has workspaces, it's likely the monorepo root
        if (packageJson.workspaces) {
          return currentDir
        }
      } catch {
        // Ignore parse errors
      }
    }

    currentDir = path.dirname(currentDir)
  }

  // No project root found, return cwd
  return process.cwd()
}

/**
 * Comment indicating the file should not be modified.
 * @type {string}
 */
export const DEFAULT_HEADER_TEXT = [
  '# ------------DO-NOT-MODIFY-THIS-FILE------------',
  '# This file was automatically generated by github-actions-workflow-ts.',
  '# Instead, modify <source-file-path>',
  '# ------------DO-NOT-MODIFY-THIS-FILE------------',
]

/**
 * Convert an absolute path to a relative path from the current working directory.
 *
 * @param {string} p - The absolute path.
 * @returns {string} - Relative path from the current working directory.
 */
export const relativePath = (p: string): string =>
  path.relative(process.cwd(), p)

/**
 * Resolves the root directory for output paths.
 * Priority: config.rootDir > auto-detected project root > cwd
 *
 * @param {WacConfig} config - The configuration object.
 * @returns {string} - The resolved root directory (absolute path).
 */
export const resolveRootDir = (config: WacConfig): string => {
  if (config.rootDir) {
    // If rootDir is relative, resolve it from cwd
    return path.resolve(process.cwd(), config.rootDir)
  }

  // Auto-detect project root
  return findProjectRoot()
}

/**
 * Resolves the output path for a workflow file.
 *
 * Priority order:
 * 1. workflow.outputPath (if set on the Workflow instance)
 * 2. config.outputPaths.workflows.overrides (first matching pattern)
 * 3. config.outputPaths.workflows.default
 * 4. DEFAULT_OUTPUT_PATH (.github/workflows)
 *
 * Output paths are resolved relative to the root directory (see resolveRootDir).
 *
 * @param {Workflow} workflow - The workflow instance.
 * @param {string} workflowFilePath - The source file path (e.g., "my-workflow.wac.ts").
 * @param {WacConfig} config - The configuration object.
 * @param {string} rootDir - The root directory for resolving output paths.
 * @returns {string} - The resolved output directory path (absolute).
 */
export const resolveOutputPath = (
  workflow: Workflow,
  workflowFilePath: string,
  config: WacConfig,
  rootDir: string,
): string => {
  let outputPath: string

  // 1. Check workflow-level outputPath (highest priority)
  if (workflow.outputPath) {
    outputPath = workflow.outputPath
  }
  // 2. Check config overrides
  else {
    const outputPathsConfig = config.outputPaths?.workflows
    if (outputPathsConfig?.overrides) {
      const filename = path.basename(workflowFilePath)
      let matched = false
      for (const override of outputPathsConfig.overrides) {
        // Match against both the full relative path and just the filename
        // This allows patterns like "packages/app-a/**/*.wac.ts" or "deploy.wac.ts"
        if (
          micromatch.isMatch(workflowFilePath, override.match) ||
          micromatch.isMatch(filename, override.match)
        ) {
          outputPath = override.path
          matched = true
          break
        }
      }
      if (!matched) {
        // 3. Check config default
        outputPath = outputPathsConfig?.default || DEFAULT_OUTPUT_PATH
      }
    } else {
      // 3. Check config default
      outputPath = outputPathsConfig?.default || DEFAULT_OUTPUT_PATH
    }
  }

  // Resolve relative paths from rootDir, absolute paths stay as-is
  if (path.isAbsolute(outputPath!)) {
    return outputPath!
  }
  return path.join(rootDir, outputPath!)
}

/**
 * Supported config file names in order of priority.
 * TypeScript config takes precedence over JSON config.
 */
export const CONFIG_FILE_NAMES = ['wac.config.ts', 'wac.config.json'] as const

/**
 * Returns the config file (synchronous version for JSON only)
 * @returns {WacConfig | undefined} - The config file as an object
 * @deprecated Use getConfigAsync for TypeScript config support
 */
export const getConfig = (): WacConfig | undefined => {
  const jsonConfigPath = path.join(process.cwd(), 'wac.config.json')

  if (!fs.existsSync(jsonConfigPath)) {
    console.log(
      '[github-actions-workflow-ts] No config (wac.config.json) file found in root dir. Using default config.',
    )

    return undefined
  }

  console.log(
    '[github-actions-workflow-ts] wac.config.json config file found in root dir',
  )

  return JSON.parse(fs.readFileSync(jsonConfigPath, 'utf-8'))
}

/**
 * Returns the config file, supporting both TypeScript and JSON formats.
 * Priority: wac.config.ts > wac.config.json
 *
 * @returns {Promise<WacConfig | undefined>} - The config file as an object
 */
export const getConfigAsync = async (): Promise<WacConfig | undefined> => {
  const cwd = process.cwd()

  // Check for TypeScript config first (higher priority)
  const tsConfigPath = path.join(cwd, 'wac.config.ts')
  if (fs.existsSync(tsConfigPath)) {
    console.log(
      '[github-actions-workflow-ts] wac.config.ts config file found in root dir',
    )

    const absolutePath = path.resolve(tsConfigPath)
    const fileUrl = pathToFileURL(absolutePath).href
    const module = await import(fileUrl)

    // Support both default export and named 'config' export
    return module.default || module.config
  }

  // Fall back to JSON config
  const jsonConfigPath = path.join(cwd, 'wac.config.json')
  if (fs.existsSync(jsonConfigPath)) {
    console.log(
      '[github-actions-workflow-ts] wac.config.json config file found in root dir',
    )

    return JSON.parse(fs.readFileSync(jsonConfigPath, 'utf-8'))
  }

  console.log(
    '[github-actions-workflow-ts] No config file found in root dir. Using default config.',
  )

  return undefined
}

/**
 * Retrieves the file paths of all workflow files in the project.
 *
 * @returns {string[] | undefined} - Array of paths to *.wac.ts files or undefined if none are found.
 */
export const getWorkflowFilePaths = (): string[] | undefined => {
  const workflowFilesPaths = fg.sync(
    fg.convertPathToPattern(process.cwd()) + '/**/*.wac.ts',
    {
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**'],
    },
  )

  if (!workflowFilesPaths || !workflowFilesPaths.length) {
    console.log(
      '[github-actions-workflow-ts] No workflow files found. Please create at least one *.wac.ts file in your project',
    )

    return
  }

  const workflowFileList = workflowFilesPaths
    .map((item) => `[github-actions-workflow-ts] --> ${relativePath(item)}`)
    .join('\n')

  console.log(
    `[github-actions-workflow-ts] Detected following .wac.ts files:\n${workflowFileList}`,
  )

  return workflowFilesPaths
}

/**
 * Dynamically imports a TypeScript workflow file using tsx.
 * Works with both ESM and CommonJS projects.
 *
 * @param {string} filePath - The path to the .wac.ts file.
 * @returns {Promise<Record<string, Workflow>>} - The exported workflows from the file.
 */
export const importWorkflowFile = async (
  filePath: string,
): Promise<Record<string, Workflow>> => {
  const absolutePath = path.resolve(filePath)
  const fileUrl = pathToFileURL(absolutePath).href

  // Dynamic import works with ESM - tsx loader handles TypeScript
  const module = await import(fileUrl)

  return module
}

/**
 * Writes the provided workflow JSON data to corresponding YAML files.
 *
 * @param {Record<string, Workflow>} workflowJSON - The workflow data in JSON format.
 * @param {string} workflowFilePath - The path to the workflow file.
 * @param {WacConfig} config - Command line arguments.
 * @param {string} rootDir - The root directory for resolving output paths.
 * @param {Set<string>} [createdDirectories] - Optional set to track directories that have been created.
 * @returns {number} - The number of workflows written.
 */
export const writeWorkflowJSONToYamlFiles = (
  workflowJSON: Record<string, Workflow>,
  workflowFilePath: string,
  config: WacConfig,
  rootDir: string,
  createdDirectories?: Set<string>,
): number => {
  let workflowCount: number = 0

  for (const workflowName in workflowJSON) {
    const workflow = workflowJSON[workflowName]

    // Skip non-Workflow exports (like default exports or other values)
    if (!workflow || !workflow.workflow || !workflow.filename) {
      continue
    }

    const workflowYaml = jsYaml.dump(workflow.workflow, {
      noRefs: !config.refs,
      ...(config.dumpOptions || {}),
    })

    // Resolve the output path for this workflow
    const outputDir = resolveOutputPath(
      workflow,
      workflowFilePath,
      config,
      rootDir,
    )

    // Create directory if not already created
    if (createdDirectories && !createdDirectories.has(outputDir)) {
      createWorkflowDirectory(outputDir)
      createdDirectories.add(outputDir)
    }

    const yamlWorkflowPath = path.join(outputDir, `${workflow.filename}.yml`)

    console.log(
      `[github-actions-workflow-ts] Writing to ${relativePath(yamlWorkflowPath)}:`,
    )

    const headerText = (config.headerText || DEFAULT_HEADER_TEXT)
      .join('\n')
      .replace('<source-file-path>', workflowFilePath)

    fs.writeFileSync(yamlWorkflowPath, [headerText, workflowYaml].join('\n'))

    workflowCount++
  }

  return workflowCount
}

/**
 * Creates the workflow output directory if it doesn't exist.
 *
 * @param {string} [outputPath] - Optional output path. Defaults to DEFAULT_OUTPUT_PATH.
 */
export const createWorkflowDirectory = (
  outputPath: string = DEFAULT_OUTPUT_PATH,
): void => {
  const workflowsDir = relativePath(outputPath)

  if (!fs.existsSync(workflowsDir)) {
    console.log(
      `[github-actions-workflow-ts] ${workflowsDir} directory not found. Creating it.`,
    )
    fs.mkdirSync(workflowsDir, { recursive: true })
  }
}

/**
 * Generates workflow files based on the provided command line arguments.
 *
 * @param {Record<string, unknown>} argv - Command line arguments.
 * @returns {Promise<void>} - A promise that resolves when the generation is completed.
 */
export const generateWorkflowFiles = async (
  argv: Record<string, unknown>,
): Promise<void> => {
  const config = (await getConfigAsync()) || {}
  const workflowFilePaths = getWorkflowFilePaths() || []
  let workflowCount = 0

  // Resolve the root directory for output paths
  const rootDir = resolveRootDir(config)
  const cwd = process.cwd()

  if (rootDir !== cwd) {
    console.log(`[github-actions-workflow-ts] Using project root: ${rootDir}`)
  }

  // Track created directories to avoid duplicate creation attempts
  const createdDirectories = new Set<string>()

  Context.__internalSetGlobalContext({
    diagnostics: new ConsoleDiagnosticsReporter(),
    diagnosticRules: config.diagnostics?.rules,
  })

  for (const filePath of workflowFilePaths) {
    const workflows = await importWorkflowFile(filePath)
    workflowCount += writeWorkflowJSONToYamlFiles(
      workflows,
      relativePath(filePath),
      {
        ...argv,
        ...config,
      } as WacConfig,
      rootDir,
      createdDirectories,
    )
  }

  console.log(
    `[github-actions-workflow-ts] Successfully generated ${workflowCount} workflow file(s)`,
  )
}
