/* eslint-disable no-console */
import * as fs from 'fs'
import * as path from 'path'
import * as jsYaml from 'js-yaml'
import fg from 'fast-glob'
import micromatch from 'micromatch'
import { pathToFileURL } from 'url'
import { Context, type Workflow } from '@github-actions-workflow-ts/lib'
import type { WacConfig } from './types/index.js'
import { ConsoleDiagnosticsReporter } from './diagnostics.js'

/**
 * Default output path for workflow files.
 */
export const DEFAULT_OUTPUT_PATH = path.join('.github', 'workflows')

/**
 * Comment indicating the file should not be modified.
 * @type {string}
 */
export const DEFAULT_HEADER_TEXT = [
  '# ------------DO-NOT-MODIFY-THIS-FILE------------',
  '# This file was automatically generated by github-actions-workflow-ts.',
  '# Instead, modify <source-file-path>',
  '# ------------DO-NOT-MODIFY-THIS-FILE------------',
]

/**
 * Convert an absolute path to a relative path from the current working directory.
 *
 * @param {string} p - The absolute path.
 * @returns {string} - Relative path from the current working directory.
 */
export const relativePath = (p: string): string =>
  path.relative(process.cwd(), p)

/**
 * Resolves the output path for a workflow file.
 *
 * Priority order:
 * 1. workflow.outputPath (if set on the Workflow instance)
 * 2. config.outputPaths.workflows.overrides (first matching pattern)
 * 3. config.outputPaths.workflows.default
 * 4. DEFAULT_OUTPUT_PATH (.github/workflows)
 *
 * @param {Workflow} workflow - The workflow instance.
 * @param {string} workflowFilePath - The source file path (e.g., "my-workflow.wac.ts").
 * @param {WacConfig} config - The configuration object.
 * @returns {string} - The resolved output directory path.
 */
export const resolveOutputPath = (
  workflow: Workflow,
  workflowFilePath: string,
  config: WacConfig,
): string => {
  // 1. Check workflow-level outputPath (highest priority)
  if (workflow.outputPath) {
    return workflow.outputPath
  }

  // 2. Check config overrides
  const outputPathsConfig = config.outputPaths?.workflows
  if (outputPathsConfig?.overrides) {
    const filename = path.basename(workflowFilePath)
    for (const override of outputPathsConfig.overrides) {
      // Match against both the full relative path and just the filename
      // This allows patterns like "packages/app-a/**/*.wac.ts" or "deploy.wac.ts"
      if (
        micromatch.isMatch(workflowFilePath, override.match) ||
        micromatch.isMatch(filename, override.match)
      ) {
        return override.path
      }
    }
  }

  // 3. Check config default
  if (outputPathsConfig?.default) {
    return outputPathsConfig.default
  }

  // 4. Fall back to hardcoded default
  return DEFAULT_OUTPUT_PATH
}

/**
 * Returns the config file
 * @returns { Record<string, any> | undefined} - The config file as an object
 */
export const getConfig = (): WacConfig | undefined => {
  const configFilePath = path.join(process.cwd(), 'wac.config.json')

  if (!fs.existsSync(configFilePath)) {
    console.log(
      '[github-actions-workflow-ts] No config (wac.config.json) file found in root dir. Using default config.',
    )

    return undefined
  }

  console.log(
    '[github-actions-workflow-ts] wac.config.json config file found in root dir',
  )

  return JSON.parse(fs.readFileSync(configFilePath, 'utf-8'))
}

/**
 * Retrieves the file paths of all workflow files in the project.
 *
 * @returns {string[] | undefined} - Array of paths to *.wac.ts files or undefined if none are found.
 */
export const getWorkflowFilePaths = (): string[] | undefined => {
  const workflowFilesPaths = fg.sync(
    fg.convertPathToPattern(process.cwd()) + '/**/*.wac.ts',
    {
      onlyFiles: true,
      dot: true,
    },
  )

  if (!workflowFilesPaths || !workflowFilesPaths.length) {
    console.log(
      '[github-actions-workflow-ts] No workflow files found. Please create at least one *.wac.ts file in your project',
    )

    return
  }

  const workflowFileList = workflowFilesPaths
    .map((item) => `[github-actions-workflow-ts] --> ${relativePath(item)}`)
    .join('\n')

  console.log(
    `[github-actions-workflow-ts] Detected following .wac.ts files:\n${workflowFileList}`,
  )

  return workflowFilesPaths
}

/**
 * Dynamically imports a TypeScript workflow file using tsx.
 * Works with both ESM and CommonJS projects.
 *
 * @param {string} filePath - The path to the .wac.ts file.
 * @returns {Promise<Record<string, Workflow>>} - The exported workflows from the file.
 */
export const importWorkflowFile = async (
  filePath: string,
): Promise<Record<string, Workflow>> => {
  const absolutePath = path.resolve(filePath)
  const fileUrl = pathToFileURL(absolutePath).href

  // Dynamic import works with ESM - tsx loader handles TypeScript
  const module = await import(fileUrl)

  return module
}

/**
 * Writes the provided workflow JSON data to corresponding YAML files.
 *
 * @param {Record<string, Workflow>} workflowJSON - The workflow data in JSON format.
 * @param {string} workflowFilePath - The path to the workflow file.
 * @param {WacConfig} config - Command line arguments.
 * @param {Set<string>} [createdDirectories] - Optional set to track directories that have been created.
 * @returns {number} - The number of workflows written.
 */
export const writeWorkflowJSONToYamlFiles = (
  workflowJSON: Record<string, Workflow>,
  workflowFilePath: string,
  config: WacConfig,
  createdDirectories?: Set<string>,
): number => {
  let workflowCount: number = 0

  for (const workflowName in workflowJSON) {
    const workflow = workflowJSON[workflowName]

    // Skip non-Workflow exports (like default exports or other values)
    if (!workflow || !workflow.workflow || !workflow.filename) {
      continue
    }

    const workflowYaml = jsYaml.dump(workflow.workflow, {
      noRefs: !config.refs,
      ...(config.dumpOptions || {}),
    })

    // Resolve the output path for this workflow
    const outputDir = resolveOutputPath(workflow, workflowFilePath, config)

    // Create directory if not already created
    if (createdDirectories && !createdDirectories.has(outputDir)) {
      createWorkflowDirectory(outputDir)
      createdDirectories.add(outputDir)
    }

    const yamlWorkflowPath = path.join(outputDir, `${workflow.filename}.yml`)

    console.log(
      `[github-actions-workflow-ts] Writing to ${relativePath(yamlWorkflowPath)}:`,
    )

    const headerText = (config.headerText || DEFAULT_HEADER_TEXT)
      .join('\n')
      .replace('<source-file-path>', workflowFilePath)

    fs.writeFileSync(yamlWorkflowPath, [headerText, workflowYaml].join('\n'))

    workflowCount++
  }

  return workflowCount
}

/**
 * Creates the workflow output directory if it doesn't exist.
 *
 * @param {string} [outputPath] - Optional output path. Defaults to DEFAULT_OUTPUT_PATH.
 */
export const createWorkflowDirectory = (
  outputPath: string = DEFAULT_OUTPUT_PATH,
): void => {
  const workflowsDir = relativePath(outputPath)

  if (!fs.existsSync(workflowsDir)) {
    console.log(
      `[github-actions-workflow-ts] ${workflowsDir} directory not found. Creating it.`,
    )
    fs.mkdirSync(workflowsDir, { recursive: true })
  }
}

/**
 * Generates workflow files based on the provided command line arguments.
 *
 * @param {Record<string, unknown>} argv - Command line arguments.
 * @returns {Promise<void>} - A promise that resolves when the generation is completed.
 */
export const generateWorkflowFiles = async (
  argv: Record<string, unknown>,
): Promise<void> => {
  const config = getConfig() || {}
  const workflowFilePaths = getWorkflowFilePaths() || []
  let workflowCount = 0

  // Track created directories to avoid duplicate creation attempts
  const createdDirectories = new Set<string>()

  Context.__internalSetGlobalContext({
    diagnostics: new ConsoleDiagnosticsReporter(),
    diagnosticRules: config.diagnostics?.rules,
  })

  for (const filePath of workflowFilePaths) {
    const workflows = await importWorkflowFile(filePath)
    workflowCount += writeWorkflowJSONToYamlFiles(
      workflows,
      relativePath(filePath),
      {
        ...argv,
        ...config,
      } as WacConfig,
      createdDirectories,
    )
  }

  console.log(
    `[github-actions-workflow-ts] Successfully generated ${workflowCount} workflow file(s)`,
  )
}
