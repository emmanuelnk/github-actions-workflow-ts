import { promises as fs } from 'fs'
import * as path from 'path'
import fetch from 'node-fetch'
import { compile, type JSONSchema } from 'json-schema-to-typescript'

const GITHUB_ACTIONS_WORKFLOW_JSON_SCHEMA_URL =
  'https://raw.githubusercontent.com/SchemaStore/schemastore/refs/heads/master/src/schemas/json/github-workflow.json'

/**
 * Converts a snake_case event name to PascalCase
 * e.g., "branch_protection_rule" -> "BranchProtectionRule"
 */
function toPascalCase(str: string): string {
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
}

/**
 * Pre-processes the JSON schema to add title properties to inline event schemas.
 * This gives json-schema-to-typescript meaningful names instead of EventObject1, Types2, etc.
 */
function addTitlesToEventSchemas(schema: JSONSchema): JSONSchema {
  const onProperty = schema.properties?.on
  if (!onProperty || !Array.isArray(onProperty.oneOf)) {
    return schema
  }

  // The third oneOf option (index 2) contains the detailed event object definitions
  const eventObjectDef = onProperty.oneOf[2]
  if (!eventObjectDef?.properties) {
    return schema
  }

  for (const [eventName, eventSchema] of Object.entries(
    eventObjectDef.properties,
  )) {
    if (
      typeof eventSchema !== 'object' ||
      eventSchema === null ||
      Array.isArray(eventSchema)
    ) {
      continue
    }

    const pascalEventName = toPascalCase(eventName)

    // Add title to the event object schema if it references eventObject
    if (eventSchema.$ref === '#/definitions/eventObject') {
      eventSchema.title = `${pascalEventName}Event`
    }

    // Add title to the types property if it exists and references types
    // Direct property access (most events)
    if (eventSchema.properties?.types?.$ref === '#/definitions/types') {
      eventSchema.properties.types.title = `${pascalEventName}EventTypes`
    }

    // Handle oneOf > allOf structure (pull_request, pull_request_target, push)
    if (Array.isArray(eventSchema.oneOf)) {
      for (const oneOfItem of eventSchema.oneOf) {
        if (Array.isArray(oneOfItem?.allOf)) {
          for (const allOfItem of oneOfItem.allOf) {
            if (allOfItem?.properties?.types?.$ref === '#/definitions/types') {
              allOfItem.properties.types.title = `${pascalEventName}EventTypes`
            }
          }
        }
      }
    }
  }

  return schema
}

;(async () => {
  const jsonSchema = await fetch(GITHUB_ACTIONS_WORKFLOW_JSON_SCHEMA_URL).then(
    (response) => response.json(),
  )

  // Add titles to inline event schemas for better type names
  const processedSchema = addTitlesToEventSchemas(jsonSchema as JSONSchema)

  const outputPath = path.join(
    process.cwd(),
    'packages',
    'lib',
    'src',
    'types',
    'githubActionsWorkflow.ts',
  )

  let workflowTypes = await compile(processedSchema as JSONSchema, 'Workflow', {
    bannerComment: `
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
`,
    customName: (schema, keyNameFromDefinition) => {
      if (schema.$id === 'https://json.schemastore.org/github-workflow.json')
        return 'Workflow'
      return keyNameFromDefinition
    },
  })

  // Remove @minItems JSDoc tags that aren't valid and cause typedoc warnings
  workflowTypes = workflowTypes.replace(/^\s*\*\s*@minItems\s+\d+\s*\n/gm, '')

  await fs.writeFile(outputPath, workflowTypes)
})()
